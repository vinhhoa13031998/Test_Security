/**
  ******************************************************************************
  * @file    AccHw_rsa.h
  * @author  MCD Application Team
  * @version V3.1.0
  * @date    30-October-2015
  * @brief   Provides RSA operations with support for PKCS#1v1.5
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************/
/*!
* \page Tutorial_RSA RSA Tutorial
*
* This version (2.2) of the library supports RSA functions for signature generation/validation 
* and encryption/decryption according to PKCS#1v1.5.
*
* Note that there is a configuration switch \ref AccHw_RSA_WINDOW_SIZE that can be used to speedup
* operations with the private key.
*
* In order to pass the keys to the functions, there are two structures to be filled:
*  - \ref RSAprivKey_stt for the private key
*  - \ref RSApubKey_stt for the public key
*  The values of the byte arrays pointed by the above structures, as well as the signature \b must be
*  byte arrays where the byte at index 0 represents the most significant byte of the integer 
*  (modulus, signature or exponent). \n
*
*  The encryption and decryption functionalities also require an initialied random engine \ref RNGstate_stt 
*  and another structure to be filled: \ref RSAinOut_stt
*  which is used to store pointers to input and output buffer, together with input's size.
*
*  All members of the above functions should be filled by the user prior to calls to the RSA functions,
*  which are:
*  - \ref RSA_PKCS1v15_Sign 
*  - \ref RSA_PKCS1v15_Verify
*  - \ref RSA_PKCS1v15_Encrypt
*  - \ref RSA_PKCS1v15_Decrypt
*
* Furthermore the user has to set up the \ref membuf_stt structure to point to a buffer of suitable
* size than will be used for the internal computations.
*
* A simple usage of the RSA PKCS#1v1.5 signature generation and verification is shown below:
*
* \code
* #include "crypto.h"
* int32_t main()
* {
*   uint8_t modulus[2048/8]={ ... };
*   uint8_t public_exponent[3]={0x01,0x00,0x01};
*   uint8_t digest[CRL_SHA256_SIZE]={...};
*   uint8_t signature[2048/8];
*   uint8_t private_exponent[2048/8]={...};
*   int32_t retval;
*   RSAprivKey_stt privKey;
*   RSApubKey_stt pubKey;
*   membuf_stt mb;  
*   uint8_t preallocated_buffer[4096];
*
*   //Set up the membuf_stt structure to a preallocated (on stack) buffer of 4kB
*   mb.mSize = sizeof(preallocated_buffer);
*   mb.mUsed = 0;
*   mb.pmBuf = preallocated_buffer;
*
*   // Set values of private key
*   privKey.mExponentSize = sizeof(private_exponent);
*   privKey.pmExponent = private_exponent;
*   privKey.mModulusSize = sizeof(modulus);
*   privKey.pmModulus = modulus;
*
*   //Generate the signature, knowing that the hash has been generated by SHA-256
*   retval = RSA_PKCS1v15_Sign(&privKey, digest, E_SHA256, signature, &mb);
*   if (retval != RSA_SUCCESS)
*   { return(ERROR); }
*
*   // Set values of public key
*   pubKey.mExponentSize = sizeof(public_exponent);
*   pubKey.pmExponent = public_exponent;
*   pubKey.mModulusSize = sizeof(modulus);
*   pubKey.pmModulus = modulus;
*
*   //Verify the signature, knowing that the hash has been generated by SHA-256
*   retval = RSA_PKCS1v15_Verify(&pubKey, digest, E_SHA256, signature, &mb);
*   if (retval != SIGNATURE_VALID )
*   { return(ERROR); }
*   else
*   { return(OK); }
* }
* \endcode
*

* A simple usage of the RSA PKCS#1v1.5 encryption and decryption is shown below. 
* Note that pRNGstate is a valid RNG initialted through \ref RNGinit
*
* \code
* #include "crypto.h"
* int32_t test_encryption_decryption(RNGstate_stt * pRNGstate)
* {
*   uint8_t modulus[2048/8]={ ... };
*   uint8_t public_exponent[3]={0x01,0x00,0x01};
*   uint8_t plaintext[11]={0,1,2,3,4,5,6,7,8,9,10};
*   uint8_t ciphertext[2048/8];
*   uint8_t deciphertext[11];
*   uint8_t private_exponent[2048/8]={...};
*   int32_t retval, outSize;
*   RSAprivKey_stt privKey;
*   RSApubKey_stt pubKey;
*   RSAinOut_stt inOut_st;
*   membuf_stt mb;  
*   uint8_t preallocated_buffer[4096];
*
*   //Set up the membuf_stt structure to a preallocated (on stack) buffer of 4kB
*   mb.mSize = sizeof(preallocated_buffer);
*   mb.mUsed = 0;
*   mb.pmBuf = preallocated_buffer;
*
*   // Set values of public key
*   pubKey.mExponentSize = sizeof(public_exponent);
*   pubKey.pmExponent = public_exponent;
*   pubKey.mModulusSize = sizeof(modulus);
*   pubKey.pmModulus = modulus;
*
*   // Fill the RSAinOut_stt
*   inOut_st.pmInput = plaintext;
*   inOut_st.mInputSize = sizeof(plaintext);
*   inOut_st.pmOutput = ciphertext;
*
*   //Encrypt the message, this function will write sizeof(modulus) data
*   retval = RSA_PKCS1v15_Encrypt(&pubKey, &inOut_st, &pRNGstate, &mb);
*   if (retval != RSA_SUCCESS)
*   { return(ERROR); }
*
*   // Set values of private key
*   privKey.mExponentSize = sizeof(private_exponent);
*   privKey.pmExponent = private_exponent;
*   privKey.mModulusSize = sizeof(modulus);
*   privKey.pmModulus = modulus;
*
*   //Fill the RSAinOut_stt
*   inOut_st.pmInput = ciphertext;
*   inOut_st.mInputSize = sizeof(modulus);
*   inOut_st.pmOutput = deciphertext;
*
*   //Verify the signature, knowing that the hash has been generated by SHA-256
*   retval = RSA_PKCS1v15_Decrypt(&privKey, &inOut_st, &outSize, &mb);
*   if (retval != RSA_SUCCESS )
*   { return(ERROR); }
*   else
*   { return(OK); }
* }
* \endcode
*/

#include "PKCS#1v15/AccHw_rsa_pkcs1v15.h"
#include "LowLevel/AccHw_rsa_low_level.h"


/******************* (C) COPYRIGHT 2015 STMicroelectronics *****END OF FILE****/
